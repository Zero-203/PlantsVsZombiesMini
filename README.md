## 植物大战僵尸Mini项目文档

### **1. 项目概述**

#### **1.1 项目背景与目标**

《植物大战僵尸 Mini》是一款基于 Cocos2d-x 3.17.2 引擎开发的 2D 塔防策略游戏。项目选择复刻经典的《植物大战僵尸》核心玩法，旨在通过一个结构完整、逻辑清晰的游戏项目，深入实践现代 C++ 在复杂游戏架构中的应用，并系统掌握 Cocos2d-x 这一成熟游戏引擎的开发流程。项目核心目标包括：构建一个模块化、可扩展的游戏框架；深入运用面向对象编程思想，特别是类、继承、多态等机制；实现对游戏资源、实体行为、用户界面和游戏逻辑的有效管理与协调，为开发更复杂的交互式应用积累实战经验。

#### **1.2 核心玩法简介**

游戏继承了原作的核心策略循环。玩家将在一个由网格划分的战场中扮演防御者，通过收集“阳光”资源，在网格上种植功能各异的植物，以抵御从屏幕右侧不断袭来的僵尸波次。植物分为攻击型（如豌豆射手）、防御型（如坚果墙）和资源生产型（如向日葵），每种植物拥有独特的冷却时间、资源消耗和战斗能力。僵尸则拥有不同的生命值、移动速度和攻击力。玩家需要实时管理资源、评估威胁并部署植物，阻止僵尸突破防线到达屏幕左侧，在动态的攻防中体验策略部署与即时反应的乐趣。

#### **1.3 项目特色与已实现范围**

当前版本已实现一个可玩性高的核心原型，涵盖了塔防游戏所需的基础系统：

* **完整的实体系统**：实现了包含普通、路障、铁桶在内的3种僵尸，以及豌豆射手、向日葵、坚果墙、樱桃炸弹、土豆地雷、寒冰射手在内的6种植物，均具备差异化的属性和行为。

* **健全的游戏管理**：包含了基于网格的战场系统、阳光资源的生产与收集系统、僵尸波次生成与难度控制系统。

* **丰富的视听与交互**：具备完整的开始菜单、游戏场景、植物卡牌选择界面。游戏内提供了实时的视觉反馈（如植物受损状态、卡牌冷却进度）和听觉反馈（背景音乐、攻击音效等）。

### **2. 项目设计与结构**

#### **2.1 总体架构设计**

本项目采用**分层与模块化**的架构思想，以有效管理游戏开发的复杂度。整个架构分为四个核心层次：**资源服务层**、**核心逻辑层**、**实体对象层**和**表现交互层**，各层职责清晰，通过接口进行通信。

这种分层设计使得系统易于理解、调试、测试和扩展：

* **资源服务层** 提供基础设施，统一管理游戏资源

* **核心逻辑层** 负责游戏规则和状态管理

* **实体对象层** 通过面向对象设计实现游戏实体行为

* **表现交互层** 处理用户界面和玩家交互

各层之间通过清晰的接口进行松耦合通信，高层模块依赖于低层模块的抽象服务接口，而非具体实现。例如，`GameManager`作为中枢协调全局状态和场景切换；`GameScene`集成并驱动各个管理器与实体；`PlantCard`等UI组件通过调用管理器接口来影响游戏世界。

#### **2.2 目录结构说明**

项目目录结构严格遵循上述架构思想进行组织，确保了代码的清晰度和可读性。以下是项目的详细目录结构及其对应职责：

```text
PlantsVsZombiesMini/
├── Classes/                           # 源代码目录
│   ├── Game/                          # 核心逻辑层：游戏规则与状态管理
│   │   ├── GameManager.h/cpp          # 游戏管理器(单例)：全局状态、资源协调、流程控制
│   │   ├── GridSystem.h/cpp           # 地图格子系统：坐标转换、空间占位管理
│   │   ├── WaveManager.h/cpp          # 僵尸波次管理：难度曲线、生成调度
│   │   └── CollisionManager.h/cpp     # 碰撞检测：实体间交互逻辑
│   ├── Entities/                      # 实体对象层：游戏中的动态参与者
│   │   ├── Plant/                     # 植物类体系（面向对象设计）
│   │   │   ├── Plant.h/cpp            # 植物基类：定义通用接口与属性
│   │   │   ├── Peashooter.h/cpp       # 豌豆射手：远程攻击型植物
│   │   │   ├── Sunflower.h/cpp        # 向日葵：资源生产型植物
│   │   │   ├── WallNut.h/cpp          # 坚果墙：防御型植物
│   │   │   ├── CherryBomb.h/cpp       # 樱桃炸弹：范围伤害型植物
│   │   │   └── ...                    # 其他植物派生类
│   │   ├── Zombie/                    # 僵尸类体系（面向对象设计）
│   │   │   ├── Zombie.h/cpp           # 僵尸基类：定义通用行为与状态机
│   │   │   ├── NormalZombie.h/cpp     # 普通僵尸：基础敌人单位
│   │   │   ├── ConeHeadZombie.h/cpp   # 路障僵尸：中级护甲单位
│   │   │   ├── BucketHeadZombie.h/cpp # 铁桶僵尸：高级护甲单位
│   │   │   └── ...                    # 其他僵尸派生类
│   │   └── Projectile/                # 子弹/抛射物系统
│   │       ├── Projectile.h/cpp       # 子弹基类：飞行与碰撞管理
│   │       ├── Pea.h/cpp              # 豌豆子弹：基础攻击弹道
│   │       └── ...                    # 其他子弹类型
│   ├── UI/                            # 表现交互层：用户界面与交互
│   │   ├── MenuScene.h/cpp            # 开始菜单场景：游戏入口与导航
│   │   ├── GameScene.h/cpp            # 游戏主场景：核心玩法呈现
│   │   ├── PlantCard.h/cpp            # 植物卡牌：策略选择交互单元
│   │   └── PauseLayer.h/cpp           # 暂停界面：游戏流程控制
│   └── Resources/                     # 资源服务层：基础设施
│       ├── AudioManager.h/cpp         # 音频管理单例：背景音乐与音效控制
│       └── ResourceLoader.h/cpp       # 资源加载单例：纹理、动画预加载与缓存
├── Resources/                         # 静态资源文件
│   ├── Images/                        # 图像资源
│   │   ├── Plants/                    # 植物精灵与动画帧
│   │   ├── Zombies/                   # 僵尸精灵与动画帧
│   │   ├── UI/                        # 界面元素（按钮、图标等）
│   │   └── Backgrounds/               # 场景背景图像
│   ├── Sounds/                        # 音频资源
│   │   ├── BGM/                       # 背景音乐文件
│   │   └── SFX/                       # 音效文件（攻击、种植、收集等）
│   └── Fonts/                         # 字体文件
└── ...                                # 构建配置文件、平台特定项目文件等
```

**各层协作关系说明：**

1. **资源服务层 → 所有上层**：`ResourceLoader` 和 `AudioManager` 作为单例服务，被游戏的所有其他模块调用，提供统一的资源访问接口，隐藏了加载和缓存细节。

2. **核心逻辑层 → 实体对象层**：`GameManager` 管理游戏实体的生命周期；`WaveManager` 通过工厂模式创建僵尸实体；`GridSystem` 为植物和僵尸提供空间定位服务。

3. **实体对象层 → 核心逻辑层**：实体（植物、僵尸、子弹）通过查询管理器（如`WaveManager`获取目标列表，`GameManager`更新资源）来感知游戏世界并与之交互。

4. **表现交互层 → 核心逻辑层 & 实体对象层**：UI场景（`GameScene`）初始化并持有管理器和实体，在游戏循环中更新它们。UI控件（`PlantCard`）响应用户输入，通过调用`GameManager`和`GridSystem`接口来改变游戏状态。

5. **表现交互层 → 资源服务层**：UI元素通过`ResourceLoader`获取纹理和字体，通过`AudioManager`播放交互音效。

这种清晰的分层和模块化设计不仅使当前项目结构清晰、易于维护，也为未来的功能扩展（如新增植物/僵尸类型、添加新游戏模式、移植到移动平台）奠定了坚实的基础。每个模块都可以相对独立地进行修改和测试，符合软件工程的最佳实践。

### **3. 技术实现**

#### **3.1 资源管理**

为保障游戏体验的流畅性与稳定性，本项目构建了一个集中式的资源管理层，负责游戏中所有音频与视觉资源的加载、缓存、生命周期管理及全局控制。该设计遵循单一职责原则，将资源逻辑与游戏业务逻辑解耦，提升了代码的可维护性与可扩展性。

**1. 音频管理 (`AudioManager`)**
`AudioManager` 采用经典的**单例模式**实现，确保在整个游戏生命周期中只有一个全局的音频控制中枢，方便任何场景或对象进行调用。

* **核心功能封装**：该类封装了 Cocos2d-x 的 `SimpleAudioEngine`，提供了更高级、更易用的接口。其功能涵盖：
  
  * **背景音乐控制**：完整支持播放、暂停、恢复、停止、音量设置及循环播放。
  * **音效控制**：支持播放、停止、暂停、恢复单个或所有音效。
  * **资源生命周期管理**：提供 `preload` 和 `unload` 接口，用于预加载和卸载音频文件，优化内存使用并避免运行时卡顿。

* **设计亮点与C++特性应用**：
  
  * **单例模式 (Singleton Pattern)**：通过私有构造函数、删除拷贝构造与赋值运算符，确保了类的唯一实例，并通过静态方法 `getInstance()` 提供全局访问点。
  * **STL容器的使用**：利用 `std::map<std::string, unsigned int>` 容器 (`_soundEffectIds`) 来管理音效文件路径与播放ID的映射关系，便于对特定音效进行精准控制（如停止）。
  * **枚举类 (enum class)**：使用 `enum class SoundType` 来定义音频类型，增强了类型安全，避免了传统枚举的作用域污染和隐式转换问题。
  * **资源隔离**：通过 `_currentBackgroundMusic` 等成员变量跟踪当前状态，并在析构函数中确保资源被正确清理，体现了的 RAII（资源获取即初始化）思想。

**2. 资源加载器 (`ResourceLoader`)**
`ResourceLoader` 同样以**单例模式**实现，作为游戏素材（图片、字体、动画、音效路径）的集中配置与加载调度中心。

* **分阶段异步加载**：设计了 `LoadingPhase` 枚举，将资源加载划分为 **菜单资源**、**游戏资源** 等不同阶段。这种按需加载的策略避免了游戏启动时的长时间等待，显著提升了初始加载速度，并合理管理了内存占用。
* **统一的资源配置管理**：在初始化时，通过 `loadResourceConfig()` 方法（当前为硬编码，可扩展为读取JSON/XML配置文件）将一个逻辑资源名（如 `”menu_background”`）映射到具体的文件路径，并存储于 `std::map` 中。这种设计使资源引用在代码中更具可读性，且资源路径的变更只需修改配置，无需改动大量业务代码。
* **异步加载与缓存机制**：
  * **图片与纹理**：使用 `TextureCache::addImageAsync` 进行异步加载，防止阻塞主线程。
  * **精灵帧与动画**：通过 `SpriteFrameCache` 对动画进行管理。类内部使用 `std::map` 对常用的 `SpriteFrame` 和 `Animation` 对象进行二次缓存，以加速频繁的访问。
  * **字体与音频路径**：提供便捷的方法根据逻辑名获取实际文件路径，供 UI 系统和 `AudioManager` 使用。
* **设计亮点与C++特性应用**：
  * **单例模式与资源管理**：确保了资源配置和加载状态的全局一致性。
  * **STL容器的广泛应用**：使用 `std::map` 管理资源路径映射和对象缓存；使用 `std::vector` 组织批量加载的资源列表，代码清晰高效。
  * **接口设计**：提供了 `getSpriteFrame`, `getTexture`, `getFontPath` 等一系列简洁的获取接口，向游戏其他模块隐藏了复杂的加载和缓存细节，体现了良好的封装性。

### **3.2 游戏管理**

游戏管理模块是整个项目的控制中枢，负责协调游戏状态、场景流转、核心资源（阳光）以及多个子系统（如实体、波次）之间的运作。我们采用“管理者模式”（Manager Pattern）构建了一个层次清晰、职责分明的管理网络，确保了游戏逻辑的井然有序与高度可维护性。

**1. 全局状态中枢：GameManager**
`GameManager` 作为最高级别的全局控制器，采用**单例模式**实现，是游戏数据和流程的权威源头。

* **核心职责**：
  
  * **游戏状态管理**：通过 `GameState` 枚举（MENU, PLAYING, PAUSED, GAME_OVER）精确定义并追踪游戏的宏观状态。所有其他模块的行为都受此状态制约，例如在暂停状态下，`GameScene` 的 `update` 逻辑将被跳过。
  * **核心资源管理**：统一管理游戏内通用的“阳光”资源，提供 `addSun`、`spendSun` 等操作，并确保资源变更的安全与逻辑一致性。
  * **游戏流程控制**：提供 `startNewGame`、`pauseGame`、`resumeGame`、`gameOver`、`restartGame` 等一系列标准接口，定义了游戏的完整生命周期。
  * **场景导航**：通过 `goToMenuScene` 和 `goToGameScene` 方法，驱动 Cocos2d-x 引擎进行场景切换，并管理场景过渡效果。
  * **全局实体托管**：集中管理所有 `Projectile`（子弹）对象的生命周期，提供统一的添加、更新和清理接口，解决了子弹对象分散管理可能带来的内存泄漏或更新遗漏问题。

* **设计亮点与C++特性应用**：
  
  * **单例模式与数据持久化**：确保了全局状态的唯一性。结合 `UserDefault` 对玩家进度（如当前关卡、最高分）进行本地持久化。
  * **枚举类 (enum class) 的使用**：`GameState` 使用 `enum class`，增强了类型安全，清晰定义了有限状态机。
  * **STL容器的使用**：使用 `std::vector<Projectile*>` 管理动态子弹对象列表。在 `updateProjectiles` 方法中，展示了如何安全地使用迭代器在遍历过程中移除失效元素，这是处理动态容器时的经典模式。
  * **回调与解耦**：虽然 `GameManager` 知晓 `GameScene` 等具体类以执行场景切换，但其核心状态和资源接口是抽象的，其他系统（如UI）只需调用 `getInstance()` 即可与之交互，降低了模块间的耦合度。

**2. 游戏主场景：GameScene**
`GameScene` 继承自 `cocos2d::Scene`，是游戏核心玩法呈现与交互的具体载体。它将各类管理器与实体系统整合到一个可视化的场景中。

* **核心职责**：
  
  * **场景初始化与资源调度**：在 `init()` 方法中，依次初始化背景、网格系统 (`GridSystem`)、UI界面、植物卡牌、触摸事件，并按需调用 `ResourceLoader` 预加载游戏资源，确保运行时流畅。
  * **游戏循环驱动**：重写 `update(float delta)` 方法，作为游戏每帧逻辑的驱动力。在此方法中，它：
    1. 检查 `GameManager` 的全局状态（如是否处于PLAYING）。
    2. 更新植物卡牌冷却状态和阳光显示。
    3. 遍历并更新所有存活的 `Plant` 对象。
    4. 委托 `GameManager` 更新所有子弹 (`updateProjectiles`)。
    5. 委托 `WaveManager` 更新僵尸波次逻辑。
    6. 管理随机阳光的生成与收集。
  * **用户交互枢纽**：处理玩家所有输入，包括触摸种植、卡牌选择、暂停/继续按钮点击等，并将这些事件转化为对 `GridSystem`、`PlantFactory`、`GameManager` 等模块的调用。
  * **子系统集成与协调**：
    * 持有并初始化 `WaveManager`，设置其波次开始、结束、游戏结束等回调函数，将僵尸系统的逻辑事件（如一波完成）与场景反馈（更新UI、触发胜利条件）紧密连接。
    * 通过 `GridSystem` 将屏幕触摸坐标转换为网格逻辑坐标，并执行植物种植的合法性校验（位置是否空闲、阳光是否足够、卡牌是否冷却）。

* **设计亮点与C++特性应用**：
  
  * **清晰的初始化流程**：`init` 方法结构清晰，依次构建游戏世界，便于调试和维护。
  * **基于lambda表达式的回调**：为 `WaveManager` 设置回调时，大量使用 **C++11的lambda表达式**，以闭包形式捕获 `this` 指针，使事件响应代码内联、直观，无需定义额外的成员函数。
  * **安全的对象生命周期管理**：在 `update` 循环和析构函数中，使用`std::vector`的迭代器安全地移除已死亡或已被移出场景的 `Plant` 和随机阳光对象，防止悬挂指针。
  * **工厂模式的应用**：通过 `PlantFactory` 创建植物对象，将对象创建逻辑与场景代码分离。

**3. 战斗空间管理器：GridSystem**
`GridSystem` 是一个专注于战场空间逻辑的单例工具类，它将连续的屏幕坐标离散化为可管理的网格体系。

* **核心职责**：
  
  * **坐标转换**：提供 `worldToGrid` 和 `gridToWorldCenter` 等方法，实现屏幕像素坐标与网格行列索引之间的双向精确转换。
  * **空间占位管理**：维护一个二维 `GridCell` 数组，记录每个格子是否被植物占用及其对应的植物指针，确保游戏规则（一格一植）得以执行。
  * **触摸事件解析**：通过 `handleTouch` 方法，将原始触摸点转换为网格点击事件，并通过回调函数通知 `GameScene`。

* **设计亮点与C++特性应用**：
  
  * **数据驱动设计**：`GridCell` 结构体封装了格子的所有状态，数据组织清晰。
  * **STL容器的嵌套使用**：使用 `std::vector<std::vector<GridCell>>` 构建动态二维网格，可拓展适配不同关卡布局。
  * **函数对象 (std::function) 的应用**：通过 `GridClickCallback`（即 `std::function` 类型）设置点击回调，使网格系统与具体业务逻辑（如种植）解耦，仅负责发出“某格子被点击了”的事件。

**4. 难度节奏控制器：WaveManager**
`WaveManager` 是负责控制僵尸进攻波次、生成逻辑和游戏进程的单例管理器，它引入了时间维度和难度曲线。

* **核心职责**：
  
  * **波次状态机**：通过 `WaveState` 枚举实现一个简单的状态机（PREPARING, SPAWNING, COMPLETED, GAME_OVER），管理每一波僵尸的完整生命周期。
  * **僵尸生成调度**：根据 `WaveData` 配置（僵尸数量、生成间隔），在 `update` 中计时并按节奏调用 `spawnRandomZombie`。僵尸类型根据波次动态加权随机，实现难度递增。
  * **事件通知**：通过一系列回调函数（`_waveStartedCallback`, `_gameOverCallback` 等），将波次开始、完成、游戏结束等关键事件广播给 `GameScene`，触发UI更新和流程控制。

* **设计亮点与C++特性应用**：
  
  * **策略模式雏形**：`spawnRandomZombie` 中根据概率生成不同僵尸类型，可视为一种简单的策略选择，为未来扩展更复杂的僵尸生成算法留出空间。
  * **动态难度计算**：`WaveData` 结构体的构造函数根据波次号动态计算僵尸数量和属性，体现了数据驱动的难度设计。
  * **使用 STL 算法**：在 `cleanupZombieList` 和 `clearAllZombies` 等方法中，需要从 `std::vector<Zombie*>` 中移除元素，代码展示了在遍历容器时安全使用迭代器进行条件移除的标准模式。

### **3.3 植物系统**

植物系统是游戏策略性的核心体现，我们采用经典的面向对象继承体系与组件化思想进行构建。该系统不仅实现了多种功能各异的植物实体，更通过清晰的分层架构（基类-派生类）和设计模式（工厂模式、状态模式）确保了代码的高复用性、易扩展性与良好的可维护性，完美契合了项目对面向对象设计能力的考察要求。

**1. 基类设计：`Plant` – 统一的抽象与行为框架**
`Plant` 类继承自 `cocos2d::Sprite`，是所有具体植物类型的抽象基类，定义了植物的共性并搭建了核心行为框架。

* **核心职责与设计**：
  
  * **属性集中管理**：在基类中集中管理所有植物的通用属性，如类型(`PlantType`)、状态(`PlantState`)、生命值(`_health`)、消耗阳光(`_sunCost`)、种植冷却(`_cooldown`)、网格位置(`_row`, `_col`)等。这种设计避免了代码重复，并使得新增植物时只需关注其特性差异。
  * **基于枚举类的状态机**：使用 **C++11的`enum class`** 定义了 `PlantState` (IDLE, ATTACKING, PRODUCING, DAMAGED, DYING, DEAD)。在 `update` 方法中，根据当前状态调用对应的虚函数（如 `onIdle`），形成了一个简单的**状态模式**，优雅地组织了植物在不同时刻的行为逻辑。
  * **模板方法模式 (Template Method Pattern)**：基类的 `update` 方法定义了植物每帧更新的固定流程（检查状态、计时攻击/生产），而将具体的行为细节（如 `attack`、`produceSun`）声明为虚函数，留给派生类实现。这确保了所有植物行为框架的一致性，同时支持具体行为的灵活多变。
  * **资源与动画接口**：通过 `_resourceLoader` 引用和 `playAnimation` 方法，提供了一套统一的动画播放机制。基类处理动画缓存、播放和停止的通用逻辑，派生类只需指定动画名称。

* **C++特性与设计亮点**：
  
  * **虚函数与多态**：`attack`、`produceSun`、`takeDamage` 等关键方法被定义为虚函数，是多态行为的基础。
  * **智能的资源集成**：在 `hasZombieInAttackRange` 方法中，通过 `WaveManager` 单例获取指定行的僵尸列表进行碰撞检测，将攻击判定逻辑上移至基类，简化了攻击型植物的实现。

**2. 具体植物实现：多样化的派生类**
通过继承 `Plant` 基类，我们实现了一系列功能独特的植物，每种植物都通过重写虚函数来定制自己的行为。

* **攻击型植物代表：`Peashooter` (豌豆射手)**
  
  * **职责**：周期性地向前方发射豌豆子弹(`Projectile`)。
  * **实现**：重写 `attack` 方法，在其中调用 `shootPea` 创建并发射一个 `Projectile` 对象。其攻击逻辑完全依赖于基类 `update` 中提供的攻击计时器和 `hasZombieInAttackRange` 提供的目标检测。

* **生产型植物代表：`Sunflower` (向日葵)**
  
  * **职责**：定时产生可收集的阳光资源。
  * **实现**：重写 `produceSun` 方法。在该方法中，它不仅调用 `GameManager` 增加全局阳光计数，还负责在场景中创建带有浮动动画、旋转动画和触摸收集功能的“阳光”精灵(`Sprite`)，实现了完整的资源生产与收集体验。

* **防御型植物代表：`WallNut` (坚果墙)**
  
  * **职责**：承受大量伤害，保护后方植物。
  * **实现**：重写 `takeDamage` 方法。在调用基类方法扣除生命值后，它根据剩余生命值的百分比更新内部的 `_crackLevel`（裂缝等级），并通过改变精灵颜色、添加闪烁动画等方式，将受损状态可视化地反馈给玩家，提升了游戏的直观性和策略感。

* **瞬时伤害型植物代表：`CherryBomb` (樱桃炸弹) 与 `PotatoMine` (土豆地雷)**
  
  * **职责**：在准备完成后，对范围内的所有敌人造成巨额瞬时伤害。
  * **实现**：
    1. **延迟触发机制**：在重写的 `onIdle` 方法中进行计时 (`_explosionTimer`/`_armingTimer`)，实现种植后的准备阶段。
    2. **范围伤害计算**：在 `explode`/`trigger` 方法中，通过 `WaveManager::getActiveZombies()` 获取所有僵尸，计算其与植物中心的距离，并对范围内的所有僵尸调用 `takeDamage`。这展示了游戏实体间的交互逻辑。
    3. **视听反馈**：爆炸时，除了播放专属音效，还动态创建了粒子系统(`ParticleExplosion`)和冲击波动画，增强了战斗的表现力和爽快感。
  * **设计差异**：`CherryBomb` 定时自爆，是多行范围攻击；`PotatoMine` 需先准备(`arm`)，然后检测邻近僵尸触发(`checkZombieInTriggerRange`)，是单行近距离触发。这体现了通过调整派生类的行为参数和检测逻辑，即可实现丰富的游戏性变化。

**3. 创建者：`PlantFactory` – 工厂模式的优雅实践**
为了将对象的创建逻辑与使用逻辑解耦，我们引入了 `PlantFactory`（植物工厂）类。

* **核心职责**：提供一个静态的 `createPlant` 方法，根据传入的 `PlantType` 枚举值，创建并返回对应的具体植物对象。
* **设计优势**：
  * **封装变化**：当需要新增植物或修改植物创建过程时，只需更改工厂类，而无需修改遍布游戏场景的植物种植代码。
  * **简化客户端代码**：在 `GameScene` 中，种植植物只需一行代码：`Plant* plant = PlantFactory::createPlant(plantType);`，代码清晰且意图明确。
  * **集中配置管理**：工厂类中的 `getSunCost`、`getCooldown` 等方法集中管理了所有植物的数值配置，便于平衡性调整。

**4. 攻击的延伸：`Projectile` – 子弹系统的组件化设计**
攻击型植物的攻击行为最终体现为 `Projectile`（子弹）对象的创建与管理。我们将子弹也设计为一个独立的、具有自身生命周期的实体类。

* **核心设计**：
  * **通用子弹基类**：`Projectile` 基类管理飞行速度、方向、生存时间、碰撞检测(`checkZombieCollisions`)和基础动画。
  * **伤害类型扩展**：通过 `DamageType` 枚举和 `_splashRadius` 等属性，支持单体伤害和范围溅射伤害，为 `CherryBomb` 的爆炸和未来可能出现的“西瓜投手”等植物预留了接口。
  * **状态驱动**：拥有自己的 `ProjectileState` (FLYING, HIT, DEAD)，在 `update` 中独立管理飞行、碰撞和销毁逻辑。
  * **与游戏世界的交互**：在 `checkZombieCollisions` 中，主动从 `WaveManager` 获取僵尸列表进行碰撞检测，击中后调用僵尸的 `takeDamage` 并可能附加效果（如 `SnowPea` 子弹的冰冻效果 `freeze`）。这体现了实体间松耦合的交互方式。

### **3.4 僵尸系统**

僵尸系统是游戏中敌对势力的核心体现，负责为玩家提供策略挑战与即时对抗。本系统采用层次化、模块化的面向对象设计，构建了一个职责清晰、行为多样且易于扩展的敌人框架。从统一的基类到各具特色的派生类，再到管理创建的工厂，该系统全面展现了继承、多态、设计模式与STL容器的综合应用，确保了僵尸行为的丰富性与代码的可维护性。

**1. 通用行为与状态框架：`Zombie`基类**

`Zombie` 类继承自 `cocos2d::Sprite`，是所有具体僵尸类型的抽象模板。它定义了僵尸的通用属性、核心行为逻辑以及生命周期管理机制。

* **核心职责与设计**：
  
  * **属性与状态统一管理**：在基类中集中管理了僵尸的生命值(`_health`)、速度(`_speed`)、攻击力(`_damage`)、行列位置(`_row`)等核心属性。通过 **`enum class`** 定义的 `ZombieState`（`ALIVE`, `ATTACKING`, `DEAD`, `FROZEN`）构建了一个清晰的状态机。每帧的 `update` 方法根据当前状态（如是否发现植物目标）驱动行为切换，实现了状态驱动的逻辑组织，使得僵尸的行为流清晰可控。
  * **行为模板与多态基础**：基类提供了移动(`updateMovement`)、寻找目标(`findPlantInFront`)、攻击(`attack`)、受击(`takeDamage`)、死亡(`die`)等行为的基本实现或接口声明。其中，`takeDamage` 等关键方法被定义为**虚函数**，为派生类实现差异化行为（如护具机制）奠定了基础，是**多态性**应用的核心。
  * **资源与动画集成**：通过 `ResourceLoader` 单例获取并缓存行走、攻击、死亡动画。基类中的 `playWalkAnimation`、`playAttackAnimation` 等方法封装了动画播放逻辑，确保视觉表现与逻辑状态的同步。
  * **效果系统**：实现了冰冻(`freeze`)等状态效果。效果通过独立的计时器(`_freezeTimer`)管理，在生效期间修改移动速度并改变视觉外观（如颜色变蓝），展示了属性与表现联动的设计。

* **C++特性与设计亮点**：
  
  * **枚举类 (enum class) 强化类型安全**：`ZombieState` 和 `ZombieType` 均使用 `enum class`，避免了传统枚举的作用域污染，使代码意图更明确。
  * **虚函数构成多态骨架**：通过虚函数为子类定制行为预留了接口。
  * **基于网格的智能寻敌**：`findPlantInFront` 方法通过查询 `GridSystem` 单例，将连续的世界坐标转换为离散的网格坐标，并检查当前及前方格子是否存在植物。这种将复杂空间关系转化为数据查询的设计，高效且准确，是策略游戏AI的典型实现。

**2. 差异化实现：具体的僵尸派生类**

通过继承 `Zombie` 基类并重写特定方法，我们实现了多种特性鲜明的僵尸，充分体现了面向对象“扩展而非修改”的原则。

* **普通僵尸 (`ZombieNormal`)**：
  
  * **定位**：基础敌人单位，属性均衡。
  * **实现**：主要负责设置自身的标准属性（生命值100，速度20）和加载对应的动画资源，是其他僵尸类型的参照基准。

* **路障僵尸 (`ZombieConeHead`)**：
  
  * **定位**：拥有额外护具的中级单位。
  * **实现**：**重写 `takeDamage` 方法**，引入 `_coneHealth`（路障生命值）和 `_coneDestroyed` 状态。受伤时，优先扣除路障生命值；仅当路障被破坏后，伤害才作用于僵尸本体。护具破坏时，会触发震动动画并将外观恢复为普通僵尸，直观地反馈了状态变化。这是**多态性**最直接的体现，通过重写一个方法就改变了整个受击规则。

* **铁桶僵尸 (`ZombieBucketHead`)**：
  
  * **定位**：拥有极高耐久护具的高级单位。
  * **实现**：与路障僵尸类似，但重写的 `takeDamage` 方法中，`_bucketHealth`（铁桶生命值）更高。铁桶被破坏时，会播放一个缩放特效。其移动速度更慢，攻击力更高，通过调整基类属性的初始值实现了角色的差异化定位。

* **设计思想总结**：具体僵尸类的设计展示了如何通过 **“继承+重写”** 的模式，在复用基类绝大部分代码（如移动、状态机、动画播放）的同时，仅通过修改关键行为（如受击逻辑）和调整属性参数，就能快速创建出玩法独特的新敌人类型，极大地提升了开发效率和系统的可扩展性。

**3. 动态创建与难度管理：`ZombieFactory`工厂**

为了将僵尸对象的创建逻辑与游戏流程逻辑解耦，并实现动态的难度控制，我们引入了 `ZombieFactory`（僵尸工厂）类。

* **核心职责**：
  
  * **解耦创建逻辑**：提供静态方法 `createZombie(ZombieType)`，根据类型枚举值返回对应的具体僵尸对象。这使得 `WaveManager`（波次管理器）无需知晓具体僵尸类的构造细节，只需关心“生成什么类型”，符合**单一职责原则**。
  * **动态难度调控**：`createRandomZombie(int waveNumber)` 方法是难度曲线的执行者。它根据当前波次号动态调整不同类型僵尸的生成概率（例如，前期只生成普通僵尸，中后期逐步加入路障和铁桶僵尸）。这种**策略模式**的简易应用，将难度配置逻辑集中在一处，使游戏进程的挑战性得以平滑、可控地增长。

* **C++特性与设计亮点**：
  
  * **静态工厂方法**：通过静态方法提供创建服务，无需实例化工厂对象，使用简便。
  * **基于权重的随机逻辑**：使用 `rand() % 100` 配合条件判断实现加权随机，是一种轻量级但有效的策略选择实现。

**4. AI行为逻辑：状态驱动的自主行动**

僵尸的AI并非复杂的寻路算法，而是一个简单、实用的基于状态和规则的反应系统。

* **行为循环**：在 `update` 中，僵尸首先检查自身状态（如是否被冰冻），然后调用 `findPlantInFront` 寻找攻击目标。若发现目标，则切换至 `ATTACKING` 状态，播放攻击动画并周期性地调用 `attack` 方法；若无目标，则保持 `ALIVE` 状态，持续向左移动 (`updateMovement`)。
* **目标搜寻策略**：`findPlantInFront` 通过与 `GridSystem` 交互，实现了对前方网格的精确查询。这种基于回合制棋盘思想的实时检测，将塔防游戏的策略性（格子占据）与动作游戏的实时性（连续移动）结合起来。
* **事件驱动协同**：僵尸的死亡(`die`)和抵达终点行为，会通过调用 `WaveManager::zombieKilled/ReachedEnd` 等方法，主动通知游戏管理系统，触发后续的胜负判定和UI更新，形成了游戏实体与管理系统间**松耦合的协同**。

### **3.5 用户界面系统**

用户界面系统是连接玩家与游戏世界的桥梁，负责提供直观的交互反馈、呈现核心游戏信息并管理不同游戏状态的切换。本项目构建了一套分层清晰、响应灵敏、与游戏逻辑解耦的UI系统，涵盖菜单导航、游戏内HUD和植物选择等功能，确保了流畅、一致的用户体验。

**1. 整体架构与设计原则**  
UI系统采用Cocos2d-x内置的`ui::Widget`控件体系，并遵循**模块化**和**职责分离**的设计原则。每个界面（如开始菜单、游戏主界面）都作为独立的`Scene`或`Layer`实现，通过`GameManager`进行统一的场景切换和状态协调。UI逻辑与核心游戏逻辑严格分离：UI类主要负责处理用户输入、播放视听反馈和展示信息，而游戏状态的改变、资源的增减等则由对应的管理器（如`GameManager`）处理。这种设计使得UI层可以独立地进行迭代和优化，而不会影响底层游戏规则。

**2. 场景管理与导航：菜单场景 (`MenuScene`)**  
`MenuScene` 是游戏的起点和导航中心，承担着引导玩家、设置游戏氛围和提供基础选项的职责。

* **场景初始化与资源预加载**：在 `init()` 方法中，场景首先通过 `ResourceLoader` 预加载菜单阶段所需的资源（如背景图、按钮纹理、背景音乐），有效避免了运行时卡顿，提升了首次加载的流畅度。

* **视觉层级与反馈**：场景构建了清晰的视觉层级：背景图、Logo、功能按钮。按钮交互提供了丰富的反馈：点击时播放专属音效，并伴随一个**缩放动画**（通过`Sequence`动画实现按下和弹起效果），给予玩家明确的操作确认感。

* **事件驱动与流程控制**：按钮通过 `addTouchEventListener` 绑定事件回调。例如，“开始游戏”按钮被点击后，会先完成上述视听反馈，然后通过一个延迟动作 (`DelayTime`) 调用 `GameManager::startNewGame()` 来切换至游戏场景。这种事件驱动的模式，将用户交互与游戏流程控制解耦，使代码逻辑清晰且易于维护。

**3. 游戏核心界面：游戏场景 (`GameScene`) 与植物选择 (`PlantCard`)**  
游戏主界面是玩法与交互的集中体现，其UI设计直接服务于游戏的核心循环——资源管理与塔防部署。

* **游戏场景作为容器**：当前版本的 `GameScene` 作为顶层容器，负责初始化和持有`WaveManager`等核心游戏模块。它是集成更多UI组件（如阳光显示器、植物卡牌栏、暂停菜单）的基础框架。

* **植物卡牌——策略的具象化**：`PlantCard` 类继承自 `ui::Button`，是玩家策略选择的核心交互单元。每张卡牌代表一种可种植的植物，其设计传达了关键游戏信息：
  
  * **状态动态管理**：卡牌具备完整的**状态机**逻辑，通过 `updateCardState` 方法实时响应全局阳光资源的变化，动态调整自身透明度以提示“可购买”或“不可购买”状态。
  
  * **冷却系统与视觉反馈**：种植后，卡牌进入冷却状态(`startCooldown`)。此时，一个黑色的半透明覆盖层(`DrawNode`)会从顶部向下收缩，直观地展示了冷却进度。冷却期间，卡牌无法被选中并伴有颜色变暗的效果。冷却结束时，会播放提示音效。这一设计将抽象的“冷却时间”概念转化为直观、动态的视觉进程，提升了策略部署的体验。

**4. UI系统的C++特性与设计模式应用**

* **基于继承的控件定制**：`PlantCard` 继承自 `ui::Button`，并扩展了冷却、状态管理等游戏特有属性，是面向对象中 **“扩展”** 特性的典型应用。

* **枚举类管理状态**：在`PlantCard`内部，虽然没有显式定义`enum class`，但通过`_isAvailable`和`_isCoolingDown`布尔变量隐式定义了卡牌的状态（可用、不可用、冷却中），在实际代码中可以通过枚举类进一步强化。

* **回调机制与松耦合**：所有按钮点击都通过 **`std::function` 或 Cocos2d-x 的 `ccCallback`** 机制绑定事件处理函数。这使得UI控件自身不需要知道具体的业务逻辑，只需在特定事件发生时“通知”外部，实现了UI与业务逻辑的松耦合。

* **管理者模式的协调**：`GameManager` 作为全局协调者，被`MenuScene`、`GameScene`等UI场景所调用，驱动着游戏的整体流程。UI层负责发起“意图”（如点击开始游戏），而`GameManager`负责执行“动作”（切换场景、重置游戏），这符合**命令模式**的思想。

### **4. 如何构建与运行**

#### **4.1 开发环境与依赖**

* **操作系统**：Windows 10/11 或 macOS

* **编程语言与框架**：C++ 11/14, Cocos2d-x 3.17.2

* **编译器/IDE**：
  
  * Windows: Visual Studio 2017 或更高版本
  
  * macOS: Xcode

* **构建工具**：CMake (由 Cocos2d-x 项目模板生成)

* **第三方工具（可选，用于资源处理）**：
  
  * Audacity: 用于处理音频文件
  
  * Visual Studio 2019（Windows）/ Xcode（Mac）：代码编译与调试

#### **4.2 编译与运行步骤**

1. **环境准备**：确保已安装 Cocos2d-x 3.17.2 开发环境，并正确配置相关路径（如 `COCOS2DX_ROOT`）。

2. ```bash
   **获取源码**：使用 Git 克隆项目仓库至本地。
   bash
   git clone <repository-url>
   cd PlantsVsZombiesMini
   ```

3. **生成项目文件**：
   
   * 使用 Cocos2d-x 命令行工具或 CMake 生成对应 IDE 的项目文件。
   
   * 例如，在 Windows 上，通常可在 `proj.win32/` 目录下找到生成的 Visual Studio 解决方案文件 (`*.sln`)。

4. **编译与运行**：
   
   * 使用 Visual Studio 或 Xcode 打开项目文件，选择 `Debug` 或 `Release` 配置进行编译。
   
   * 编译成功后，在 IDE 中运行目标，或直接在输出目录找到可执行文件运行。

#### **4.3 游戏操作指南**

1. **开始游戏**：运行程序，进入开始菜单，点击“开始游戏”按钮。

2. **收集阳光**：点击从天空掉落或由向日葵产生的“阳光”图标以增加资源。

3. **选择植物**：点击屏幕底部的植物卡牌以选中。卡牌会显示阳光消耗和冷却状态（灰色覆盖层表示冷却中）。

4. **种植植物**：在战场网格的任意空闲格子上点击，即可种植已选中的植物（需满足阳光充足且卡牌不在冷却中）。

5. **进行游戏**：植物将自动攻击进入其射程的僵尸。你需要持续部署植物，抵御一波波不断增强的僵尸进攻，保护左侧防线。

6. **暂停与重新开始**：游戏过程中，可通过相应按钮暂停游戏。在暂停时，可继续或重新开始游戏。

### **5. 后续工作**

#### **5.1 优化与调整**

1. **性能优化**：引入对象池 (`Object Pool`) 技术，对频繁创建销毁的实体（如子弹、阳光、僵尸）进行复用，以减少运行时内存分配开销，提升帧率稳定性。

2. **代码重构**：进一步抽象和封装碰撞检测逻辑，可能形成一个独立的 `CollisionManager`，提供更统一、高效且可配置的碰撞处理服务。

3. **体验改进**：优化游戏平衡性数值；为更多操作添加平滑的动画过渡；实现更完善的游戏存档与读档功能。

#### **5.2 扩充内容**

1. **内容扩展**：设计并实现更多植物（如缠绕海草、玉米加农炮）和僵尸（如舞王僵尸、气球僵尸）类型，引入新的游戏机制（如植物升级、僵尸特殊技能）。

2. **关卡与模式**：开发具有不同地形效果（夜晚、水池、屋顶）的多样化关卡；增加“无尽模式”、“小游戏”等玩法，延长游戏生命周期。

3. **系统深化**：构建完整的植物图鉴与僵尸百科系统；加入简单的任务或成就系统以激励玩家。

4. **平台与网络**：完成移动平台 (iOS/Android) 的全面适配与性能优化；探索实现本地双人对战或简单的排行榜功能。
